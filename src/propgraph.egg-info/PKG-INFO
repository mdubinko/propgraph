Metadata-Version: 2.4
Name: propgraph
Version: 0.1.0
Summary: A general-purpose property graph database library built on SQLite
Author: PropGraph Contributors
License: MIT
Project-URL: Homepage, https://github.com/yourusername/propgraph
Project-URL: Documentation, https://github.com/yourusername/propgraph#readme
Project-URL: Repository, https://github.com/yourusername/propgraph
Project-URL: Issues, https://github.com/yourusername/propgraph/issues
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Database
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Provides-Extra: dev
Requires-Dist: pytest>=6.0; extra == "dev"
Requires-Dist: pytest-cov; extra == "dev"
Requires-Dist: black; extra == "dev"
Requires-Dist: isort; extra == "dev"
Requires-Dist: mypy; extra == "dev"

# PropGraph

A general-purpose property graph database library built on SQLite.

## Features

- **ðŸ—‚ï¸ Nodes and edges with arbitrary properties** - Store any Python data type as properties
- **âš¡ CRUD operations with bulk mutations** - Individual and mass operations with transaction safety
- **ðŸ”’ Transaction support with automatic rollback** - ACID compliance for data integrity
- **ðŸ”— Lazy query evaluation with method chaining** - XPath-inspired fluent API
- **ðŸ›¡ï¸ Type-safe operations** - Modern Python type hints and comprehensive testing
- **ðŸ“¦ Zero external dependencies** - Pure Python standard library implementation

## Installation

### Development Setup (with uv)
```bash
git clone https://github.com/yourusername/propgraph.git
cd propgraph
uv venv
uv pip install -e .
```

### Development Setup (with pip)
```bash
git clone https://github.com/yourusername/propgraph.git
cd propgraph
python -m venv .venv
source .venv/bin/activate  # or .venv\Scripts\activate on Windows
pip install -e .
```

### As Local Dependency
Add to your `pyproject.toml`:
```toml
[dependencies]
propgraph = {path = "../propgraph", develop = true}
```

## Quick Start

```python
from propgraph import PropertyGraph

# Create an in-memory graph
with PropertyGraph() as graph:
    # Create nodes with properties
    alice = graph.add_node("User", name="Alice", age=30, active=True)
    bob = graph.add_node("User", name="Bob", age=25, active=False)
    project = graph.add_node("Project", name="Web App", status="active")
    
    # Create relationships
    works_on = graph.add_edge(alice, "WORKS_ON", project, role="Lead", since="2023-01-01")
    
    # Query nodes
    active_users = list(graph.nodes("User", active=True))
    print(f"Found {len(active_users)} active users")
    
    # Bulk operations
    deleted = graph.nodes("User", active=False).delete().execute()
    print(f"Deleted {deleted} inactive users")
```

## Core Features

### Basic CRUD Operations

```python
# Create
user = graph.add_node("User", name="Alice", email="alice@example.com")
friendship = graph.add_edge(user1, "FRIENDS", user2, since="2023-01-01")

# Read
name = user.prop("name")
active_users = list(graph.nodes("User", active=True))

# Update
user.set_prop("last_login", "2023-12-01")

# Delete (individual)
user.set_prop("active", False)  # Mark inactive instead of deleting
```

### Bulk Mutations

```python
# Delete all temporary data
temp_deleted = graph.nodes("TempUser").delete().execute()
expired_edges = graph.edges("SESSION", expired=True).delete().execute()

# Chain filters for complex operations
inactive_old_users = (graph.nodes("User")
                     .filter(active=False)
                     .filter(last_login__before="2022-01-01")
                     .delete()
                     .execute())
```

### Transaction Safety

```python
# Automatic transactions for bulk operations
try:
    count = graph.nodes("BadData").delete().execute()
    print(f"Cleaned up {count} items")
except Exception as e:
    print("Cleanup failed, no data was modified")
    # Automatic rollback on error

# Manual transaction control  
with graph._storage.transaction():
    user = graph.add_node("User", name="Alice")
    project = graph.add_node("Project", name="New Project")
    graph.add_edge(user, "OWNS", project)
    # All committed together, or all rolled back on error
```

### Query Chaining

```python
# XPath-style lazy evaluation
senior_engineers = (graph.nodes("User")
                   .filter(department="Engineering")
                   .filter(level="Senior")
                   .filter(active=True))

# Execute only when iterating
for engineer in senior_engineers:
    print(f"Senior Engineer: {engineer.prop('name')}")

# Or get count without full iteration
count = len(list(senior_engineers.limit(0)))  # Efficient counting
```

## Examples

See the `examples/` directory for real-world usage patterns:

```bash
# Run all examples
./bin/examples.sh

# Run specific examples
./bin/examples.sh social      # Social network modeling
./bin/examples.sh knowledge   # Knowledge graph patterns  
./bin/examples.sh deps        # Dependency analysis
```

## API Reference

### PropertyGraph Class

The main interface to the graph database.

#### Constructor
- `PropertyGraph(db_path: Optional[str] = None)` - Create graph (in-memory if no path)

#### Node Operations  
- `add_node(node_type: str, **properties) -> NodeProxy` - Create node
- `nodes(node_type: Optional[str] = None, **properties) -> NodeIterator` - Query nodes

#### Edge Operations
- `add_edge(source, edge_type: str, target, **properties) -> EdgeProxy` - Create edge  
- `edges(edge_type: Optional[str] = None, **properties) -> EdgeIterator` - Query edges

#### Graph Operations
- `node_count() -> int` - Total number of nodes
- `edge_count() -> int` - Total number of edges
- `prop(key: str) -> Any` - Get graph property
- `set_prop(key: str, value: Any) -> Self` - Set graph property (chainable)

### NodeProxy Class

Lightweight proxy for individual nodes.

- `prop(key: str) -> Any` - Get property value
- `set_prop(key: str, value: Any) -> Self` - Set property (chainable)
- `to_json() -> dict` - Export as dictionary
- `timestamp() -> float` - Creation timestamp

### EdgeProxy Class

Lightweight proxy for individual edges.

- `prop(key: str) -> Any` - Get property value  
- `set_prop(key: str, value: Any) -> Self` - Set property (chainable)
- `to_json() -> dict` - Export as dictionary
- `src_id` / `dst_id` - Source and destination node IDs

## Testing

```bash
# Run all tests (pytest)
./bin/test.sh

# Run specific test suites
./bin/test.sh fast           # Fast tests only
./bin/test.sh integration    # Integration tests  
./bin/test.sh coverage       # With coverage report

# Run original comprehensive test
./bin/test.sh original
```

## Development

### Quick Start
```bash
# Set up development environment (uv recommended)
./bin/dev.sh setup

# Test basic functionality 
./bin/dev.sh basic

# Run all tests
./bin/test.sh

# Format code and run checks
./bin/dev.sh lint
```

### Requirements
- Python 3.10+ (uses match expressions and modern type hints)
- SQLite 3.7.11+ (for foreign key support)  
- Zero external runtime dependencies
- [uv](https://docs.astral.sh/uv/) recommended for development

### Development Scripts
- `./bin/test.sh` - Run tests with various options
- `./bin/examples.sh` - Run examples  
- `./bin/dev.sh` - Development utilities (setup, lint, check, etc.)

### Architecture
- **`src/propgraph/storage.py`**: SQLite operations and type mapping
- **`src/propgraph/query.py`**: Query building and lazy evaluation  
- **`src/propgraph/core.py`**: Main API and proxy classes

### Contributing
1. Fork the repository
2. Create a feature branch  
3. Run `./bin/dev.sh setup` for development environment
4. Add tests for new functionality
5. Run `./bin/dev.sh check` to verify all checks pass
6. Submit a pull request

## License

MIT License - see LICENSE file for details.

## History

Originally developed as part of the Copah codebase analysis tool, PropGraph was extracted into a standalone library to enable reuse across multiple projects. It provides a clean, Pythonic interface to SQLite-based graph operations with modern features like lazy evaluation, bulk operations, and transaction safety.
